#!/usr/bin/env python3
"""
PDF Generation Service - Creates comprehensive event plans as PDF documents
"""

import os
import json
from datetime import datetime
from typing import Dict, List, Any
from reportlab.lib.pagesizes import letter
from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
from reportlab.lib.units import inch
from reportlab.lib.colors import HexColor
from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle, Image
from reportlab.lib.enums import TA_CENTER, TA_LEFT
from reportlab.lib.utils import ImageReader
import io
import httpx
from PIL import Image as PILImage

class PDFPlanGenerationService:
    """Generates comprehensive event plan PDFs based on user selections"""
    
    def __init__(self):
        self.styles = getSampleStyleSheet()
        self._create_custom_styles()
        print("‚úÖ Initialized PDF Plan Generation Service")
    
    def _create_custom_styles(self):
        """Create custom styles for the PDF"""
        # Title style
        self.styles.add(ParagraphStyle(
            name='EventTitle',
            parent=self.styles['Heading1'],
            fontSize=24,
            textColor=HexColor('#F59E0B'),
            alignment=TA_CENTER,
            spaceAfter=20
        ))
        
        # Section header style
        self.styles.add(ParagraphStyle(
            name='SectionHeader',
            parent=self.styles['Heading2'],
            fontSize=16,
            textColor=HexColor('#059669'),
            spaceBefore=20,
            spaceAfter=10
        ))
        
        # Recommendation item style
        self.styles.add(ParagraphStyle(
            name='RecommendationItem',
            parent=self.styles['Normal'],
            fontSize=12,
            leftIndent=20,
            spaceBefore=8,
            spaceAfter=8
        ))
    
    async def generate_event_plan_pdf(self, event_data: Dict, user_selections: Dict = None) -> bytes:
        """Generate comprehensive event plan PDF"""
        
        # Create PDF buffer
        buffer = io.BytesIO()
        doc = SimpleDocTemplate(buffer, pagesize=letter, rightMargin=72, leftMargin=72, topMargin=72, bottomMargin=18)
        
        # Build PDF content
        story = []
        
        # Title
        title = f"{event_data.get('event_type', 'Event').title()} Plan"
        story.append(Paragraph(title, self.styles['EventTitle']))
        story.append(Spacer(1, 20))
        
        # Event Overview
        story.extend(self._create_event_overview(event_data))
        
        # Generate AI-powered comprehensive plan
        ai_plan = await self._generate_ai_plan(event_data, user_selections)
        
        # Add AI-generated sections
        story.extend(self._create_ai_generated_sections(ai_plan))
        
        # Footer
        story.append(Spacer(1, 20))
        story.append(Paragraph(
            f"Generated by Tiles AI Event Planner on {datetime.now().strftime('%B %d, %Y')}",
            self.styles['Normal']
        ))
        
        # Build PDF
        doc.build(story)
        
        # Get PDF bytes
        pdf_bytes = buffer.getvalue()
        buffer.close()
        
        return pdf_bytes
    
    def _create_event_overview(self, event_data: Dict) -> List:
        """Create event overview section"""
        content = []
        
        content.append(Paragraph("Event Overview", self.styles['SectionHeader']))
        
        # Event details table
        details = [
            ["Event Type", event_data.get('event_type', 'Not specified')],
            ["Location", event_data.get('location', 'Not specified')],
            ["Guest Count", str(event_data.get('guest_count', 'Not specified'))],
            ["Budget", event_data.get('budget', 'Not specified')],
            ["Meal Type", event_data.get('meal_type', 'Not specified')],
            ["Dietary Restrictions", event_data.get('dietary_restrictions', 'None')]
        ]
        
        table = Table(details, colWidths=[2*inch, 4*inch])
        table.setStyle(TableStyle([
            ('BACKGROUND', (0, 0), (0, -1), HexColor('#F3F4F6')),
            ('TEXTCOLOR', (0, 0), (-1, -1), HexColor('#374151')),
            ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
            ('FONTNAME', (0, 0), (-1, -1), 'Helvetica'),
            ('FONTSIZE', (0, 0), (-1, -1), 10),
            ('BOTTOMPADDING', (0, 0), (-1, -1), 12),
            ('GRID', (0, 0), (-1, -1), 1, HexColor('#E5E7EB'))
        ]))
        
        content.append(table)
        content.append(Spacer(1, 20))
        
        return content
    
    def _create_music_section(self, music_data: List[Dict]) -> List:
        """Create music recommendations section"""
        content = []
        
        content.append(Paragraph("üéµ Music Recommendations", self.styles['SectionHeader']))
        
        for i, music in enumerate(music_data, 1):
            title = music.get('title', 'Unknown Track')
            artist = music.get('artist', 'Unknown Artist')
            platform = music.get('platform', 'Unknown')
            
            text = f"{i}. <b>{title}</b> by {artist} ({platform})"
            content.append(Paragraph(text, self.styles['RecommendationItem']))
        
        content.append(Spacer(1, 15))
        return content
    
    def _create_venues_section(self, venue_data: List[Dict]) -> List:
        """Create venue recommendations section"""
        content = []
        
        content.append(Paragraph("üèõÔ∏è Venue Recommendations", self.styles['SectionHeader']))
        
        for i, venue in enumerate(venue_data, 1):
            name = venue.get('name', 'Unknown Venue')
            address = venue.get('address', 'Address not available')
            venue_type = venue.get('venue_type', 'venue')
            rating = venue.get('business_rating', 0)
            
            text = f"{i}. <b>{name}</b> ({venue_type.replace('_', ' ').title()})"
            if rating:
                text += f" - Rating: {rating}/5"
            text += f"<br/>{address}"
            
            content.append(Paragraph(text, self.styles['RecommendationItem']))
        
        content.append(Spacer(1, 15))
        return content
    
    def _create_food_section(self, food_data: List[Dict]) -> List:
        """Create food recommendations section"""
        content = []
        
        content.append(Paragraph("üçΩÔ∏è Food Recommendations", self.styles['SectionHeader']))
        
        for i, food in enumerate(food_data, 1):
            name = food.get('name', 'Unknown Food')
            cuisine_type = food.get('cuisine_type', 'Unknown')
            price_range = food.get('price_range', 'Price not available')
            
            text = f"{i}. <b>{name}</b> ({cuisine_type}) - {price_range}"
            if food.get('description'):
                text += f"<br/>{food['description']}"
            
            content.append(Paragraph(text, self.styles['RecommendationItem']))
        
        content.append(Spacer(1, 15))
        return content
    
    def _create_timeline_section(self, event_data: Dict) -> List:
        """Create event timeline section"""
        content = []
        
        content.append(Paragraph("üìÖ Event Timeline", self.styles['SectionHeader']))
        
        # Generate timeline based on event type
        event_type = event_data.get('event_type', 'event')
        timeline = self._generate_timeline_for_event_type(event_type)
        
        for item in timeline:
            content.append(Paragraph(f"‚Ä¢ {item}", self.styles['RecommendationItem']))
        
        content.append(Spacer(1, 15))
        return content
    
    def _create_checklist_section(self, event_data: Dict) -> List:
        """Create event checklist section"""
        content = []
        
        content.append(Paragraph("‚úÖ Event Checklist", self.styles['SectionHeader']))
        
        # Generate checklist based on event type
        event_type = event_data.get('event_type', 'event')
        checklist = self._generate_checklist_for_event_type(event_type)
        
        for item in checklist:
            content.append(Paragraph(f"‚òê {item}", self.styles['RecommendationItem']))
        
        content.append(Spacer(1, 15))
        return content
    
    async def _generate_ai_plan(self, event_data: Dict, user_selections: Dict) -> Dict:
        """Generate comprehensive event plan using GPT-4"""
        
        # Prepare context for AI
        context = f"""
Event Details:
- Type: {event_data.get('event_type', 'Event')}
- Location: {event_data.get('location', 'Not specified')}
- Guest Count: {event_data.get('guest_count', 'Not specified')}
- Budget: {event_data.get('budget', 'Not specified')}
- Meal Type: {event_data.get('meal_type', 'Not specified')}
- Dietary Restrictions: {event_data.get('dietary_restrictions', 'None')}

Generated Recommendations:
- Music: {len(user_selections.get('music', []))} curated tracks
- Venues: {len(user_selections.get('venues', []))} recommended venues
- Food: {len(user_selections.get('food', []))} catering options

Selected Venues:
{self._format_venues_for_ai(user_selections.get('venues', []))}

Selected Music:
{self._format_music_for_ai(user_selections.get('music', []))}

Selected Food:
{self._format_food_for_ai(user_selections.get('food', []))}
"""

        prompt = f"""You are an expert event planner creating a comprehensive wedding plan. Use your knowledge of event planning best practices, local considerations, and cultural factors.

{context}

Create a detailed, professional event plan that leverages both the provided data and your internal knowledge about event planning, venues, costs, and logistics.

Return a well-structured JSON with these sections:

{{
  "executive_summary": "2-3 paragraph vision and overview of this specific event",
  "timeline": [
    "6 months before: Specific actionable task for this event type and location",
    "4 months before: Another specific task",
    "2 months before: Another task",
    "1 month before: Another task", 
    "1 week before: Another task",
    "Day of: Event execution steps"
  ],
  "budget_breakdown": {{
    "venue": "Cost estimate - Specific venue costs for {event_data.get('location', 'the location')}",
    "catering": "Cost estimate - Catering costs for {event_data.get('guest_count', 'guests')} with {event_data.get('dietary_restrictions', 'dietary restrictions')}",
    "music": "Cost estimate - Music and entertainment",
    "decorations": "Cost estimate - Decorations and flowers",
    "photography": "Cost estimate - Photography services",
    "transportation": "Cost estimate - Guest transportation",
    "miscellaneous": "Cost estimate - Contingency and extras"
  }},
  "vendor_coordination": "Detailed vendor management strategy using the selected venues/music/food",
  "guest_experience": "Comprehensive guest experience from arrival to departure",
  "logistics": "Practical setup, execution, and breakdown procedures",
  "final_checklist": [
    "Task 1: Specific actionable item",
    "Task 2: Another specific item",
    "Task 3: Another specific item"
  ]
}}

Make this plan:
- Specific to {event_data.get('location', 'the specified location')} and its local culture and logistics
- Realistic for the {event_data.get('budget', 'specified budget')} with actual cost estimates appropriate for this location
- Account for location-specific considerations and local customs
- Include cultural considerations appropriate for this location and event type
- Use the provided music, venue, and food selections
- Be professional, detailed, and actionable"""

        try:
            print(f"ü§ñ Calling GPT-4 for PDF generation...")
            async with httpx.AsyncClient() as client:
                response = await client.post(
                    "https://api.openai.com/v1/chat/completions",
                    headers={
                        "Authorization": f"Bearer {os.getenv('OPENAI_API_KEY')}",
                        "Content-Type": "application/json"
                    },
                    json={
                        "model": "gpt-4.1-2025-04-14",
                        "messages": [{"role": "user", "content": prompt}],
                        "response_format": {"type": "json_object"},
                        "temperature": 0.7,
                        "max_tokens": 2500
                    },
                    timeout=60.0
                )
                
                print(f"üîç GPT-4 response status: {response.status_code}")
                
                if response.status_code == 200:
                    result = response.json()
                    content = result["choices"][0]["message"]["content"]
                    print(f"üîç GPT response length: {len(content)} chars")
                    
                    # Parse the JSON response
                    try:
                        import json
                        parsed_plan = json.loads(content)
                        print(f"‚úÖ Successfully parsed JSON with keys: {list(parsed_plan.keys())}")
                        return parsed_plan
                    except json.JSONDecodeError as e:
                        print(f"‚ùå JSON parsing error: {e}")
                        print(f"üîç Raw content: {content}")
                        # Fallback to text content
                        return {"executive_summary": content}
                else:
                    print(f"‚ùå GPT API error: {response.status_code}")
                    print(f"üîç Response: {response.text}")
                        
        except Exception as e:
            print(f"‚ùå AI plan generation error: {e}")
            import traceback
            traceback.print_exc()
            
        # Fallback plan
        return {
            "executive_summary": f"A comprehensive {event_data.get('event_type', 'event')} plan for {event_data.get('guest_count', 'your guests')} in {event_data.get('location', 'your chosen location')}.",
            "timeline": ["6 months before: Initial planning", "3 months before: Vendor bookings", "1 month before: Final preparations", "Day of: Event execution"],
            "budget_breakdown": f"Budget allocation for {event_data.get('budget', 'your budget')} across venue, catering, entertainment, and extras.",
            "vendor_coordination": "Coordinate with selected venues, music providers, and catering services.",
            "guest_experience": "Ensure comfortable and memorable experience for all attendees.",
            "logistics": "Detailed setup, execution, and cleanup procedures.",
            "final_checklist": "Complete checklist of all required tasks and preparations."
        }
    
    def _format_venues_for_ai(self, venues: List[Dict]) -> str:
        """Format venue data for AI context"""
        if not venues:
            return "No venues selected"
        
        formatted = []
        for venue in venues:
            formatted.append(f"- {venue.get('name', 'Unknown')}: {venue.get('address', 'No address')} (Rating: {venue.get('business_rating', 'N/A')})")
        return "\n".join(formatted)
    
    def _format_music_for_ai(self, music: List[Dict]) -> str:
        """Format music data for AI context"""
        if not music:
            return "No music selected"
        
        formatted = []
        for track in music:
            formatted.append(f"- {track.get('title', 'Unknown')}: {track.get('artist', 'Unknown Artist')}")
        return "\n".join(formatted)
    
    def _format_food_for_ai(self, food: List[Dict]) -> str:
        """Format food data for AI context"""
        if not food:
            return "No food selected"
        
        formatted = []
        for item in food:
            formatted.append(f"- {item.get('name', 'Unknown')}: {item.get('cuisine_type', 'Unknown cuisine')} ({item.get('price_range', 'Price TBD')})")
        return "\n".join(formatted)
    
    def _create_ai_generated_sections(self, ai_plan: Dict) -> List:
        """Create PDF sections from AI-generated plan"""
        content = []
        
        # Executive Summary
        if ai_plan.get('executive_summary'):
            content.append(Paragraph("Executive Summary", self.styles['SectionHeader']))
            content.append(Paragraph(ai_plan['executive_summary'], self.styles['Normal']))
            content.append(Spacer(1, 15))
        
        # Timeline
        if ai_plan.get('timeline'):
            content.append(Paragraph("üìÖ Detailed Timeline", self.styles['SectionHeader']))
            timeline_items = ai_plan['timeline']
            if isinstance(timeline_items, list):
                for item in timeline_items:
                    content.append(Paragraph(f"‚Ä¢ {item}", self.styles['RecommendationItem']))
            else:
                content.append(Paragraph(timeline_items, self.styles['Normal']))
            content.append(Spacer(1, 15))
        
        # Budget Breakdown
        if ai_plan.get('budget_breakdown'):
            content.append(Paragraph("üí∞ Budget Breakdown", self.styles['SectionHeader']))
            budget_data = ai_plan['budget_breakdown']
            
            if isinstance(budget_data, dict):
                # Format as structured budget items
                for category, cost in budget_data.items():
                    content.append(Paragraph(f"‚Ä¢ {category.title()}: {cost}", self.styles['RecommendationItem']))
            else:
                # Fallback to text
                content.append(Paragraph(budget_data, self.styles['Normal']))
            content.append(Spacer(1, 15))
        
        # Vendor Coordination
        if ai_plan.get('vendor_coordination'):
            content.append(Paragraph("ü§ù Vendor Coordination", self.styles['SectionHeader']))
            content.append(Paragraph(ai_plan['vendor_coordination'], self.styles['Normal']))
            content.append(Spacer(1, 15))
        
        # Guest Experience
        if ai_plan.get('guest_experience'):
            content.append(Paragraph("‚ú® Guest Experience", self.styles['SectionHeader']))
            content.append(Paragraph(ai_plan['guest_experience'], self.styles['Normal']))
            content.append(Spacer(1, 15))
        
        # Logistics
        if ai_plan.get('logistics'):
            content.append(Paragraph("‚öôÔ∏è Logistics & Operations", self.styles['SectionHeader']))
            content.append(Paragraph(ai_plan['logistics'], self.styles['Normal']))
            content.append(Spacer(1, 15))
        
        # Final Checklist
        if ai_plan.get('final_checklist'):
            content.append(Paragraph("‚úÖ Final Checklist", self.styles['SectionHeader']))
            checklist_items = ai_plan['final_checklist']
            if isinstance(checklist_items, list):
                for item in checklist_items:
                    content.append(Paragraph(f"‚òê {item}", self.styles['RecommendationItem']))
            else:
                content.append(Paragraph(checklist_items, self.styles['Normal']))
            content.append(Spacer(1, 15))
        
        return content
    
    def _generate_timeline_for_event_type(self, event_type: str) -> List[str]:
        """Generate timeline based on event type"""
        if 'wedding' in event_type.lower():
            if 'beach' in event_type.lower():
                return [
                    "6 months before: Book beach venue (permits required) and send save-the-dates",
                    "3 months before: Send invitations with weather contingency info and finalize catering",
                    "1 month before: Confirm all vendors have beach access and final guest count",
                    "1 week before: Check weather forecast and confirm backup plans",
                    "Day of: Setup early (before crowds), ceremony at sunset, reception under stars"
                ]
            else:
                return [
                    "6 months before: Book venue and send save-the-dates",
                    "3 months before: Send invitations and finalize catering",
                    "1 month before: Confirm all vendors and final guest count",
                    "1 week before: Final venue walkthrough and rehearsal",
                    "Day of: Setup, ceremony, and reception"
                ]
        elif 'birthday' in event_type.lower():
            return [
                "2 weeks before: Send invitations and plan activities",
                "1 week before: Confirm guest count and prepare decorations",
                "2 days before: Shop for food and party supplies",
                "Day of: Setup decorations and prepare food",
                "Party time: Enjoy the celebration!"
            ]
        else:
            return [
                "3 weeks before: Plan and send invitations",
                "1 week before: Confirm attendance and prepare materials",
                "2 days before: Setup venue and arrange catering",
                "Day of: Final preparations and event execution",
                "After: Clean up and follow up with attendees"
            ]
    
    def _generate_checklist_for_event_type(self, event_type: str) -> List[str]:
        """Generate checklist based on event type"""
        if 'wedding' in event_type.lower():
            if 'beach' in event_type.lower():
                return [
                    "Obtain beach venue permit and confirm access",
                    "Book officiant experienced with beach ceremonies",
                    "Send invitations with beach-specific details (attire, weather)",
                    "Arrange catering with beach setup capabilities",
                    "Hire photographer familiar with beach/sunset lighting",
                    "Plan ceremony music (consider wind conditions)",
                    "Rent tent/umbrellas for weather protection",
                    "Coordinate guest transportation and parking",
                    "Prepare welcome bags (sunscreen, water, flip-flops)",
                    "Schedule hair/makeup (consider beach conditions)",
                    "Obtain marriage license",
                    "Plan backup indoor location"
                ]
            else:
                return [
                    "Book venue and officiant",
                    "Send invitations and track RSVPs",
                    "Arrange catering and bar service",
                    "Hire photographer and videographer",
                    "Plan ceremony and reception music",
                    "Coordinate transportation",
                    "Prepare wedding favors and decorations",
                    "Schedule hair and makeup appointments",
                    "Obtain marriage license",
                    "Plan honeymoon"
                ]
        elif 'birthday' in event_type.lower():
            return [
                "Send invitations to guests",
                "Plan party activities and games",
                "Order or bake birthday cake",
                "Decorate party venue",
                "Prepare party favors",
                "Plan menu and drinks",
                "Setup music and entertainment",
                "Prepare camera for photos",
                "Clean up supplies ready"
            ]
        else:
            return [
                "Send event invitations",
                "Book appropriate venue",
                "Arrange catering or refreshments",
                "Setup necessary equipment",
                "Prepare presentation materials",
                "Coordinate with speakers/presenters",
                "Arrange seating and logistics",
                "Prepare welcome materials",
                "Plan follow-up activities"
            ]

# Global instance
pdf_service = PDFPlanGenerationService()